#!/bin/bash

set -e

# Each log output goes to stderrr, so that we can return value from functions
# with stdout. (Curl does the same).

program_name() {
  echo "DOCKER-OPS"
}
log_debug() {
  if [ "${RELEASER_LOG_LEVEL}" == "debug" ]; then
    echo -e "$(date "+%d-%m-%Y %T") $(program_name) debug: ${1}" >&2
  fi
}
log_info() {
  echo -e "$(date "+%d-%m-%Y %T") $(program_name) info: ${1}" >&2
}
log_error() {
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(program_name) error: $1\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(program_name) error: File: ${BASH_SOURCE[0]}\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(program_name) error: Line numbers: ${BASH_LINENO[*]}\e[0m" >&2
}
log_warn() {
  echo -e "\e[33m$(date "+%d-%m-%Y %T") $(program_name) warn: $1\e[0m" >&2
}

function docker_build {
  image_dir="$1"
  image_name="$2"
  image_tag="$3"

  if [[ -z "${image_dir}" ]];then
    log_error "image_dir not set"
    return 1
  fi
  log_info "image_dir set to: ${image_dir}"
  if [[ -z "${image_name}" ]];then
    log_error "image_name not set"
    return 1
  fi
  log_info "image_name set to: ${image_name}"
  initial_dir="$(pwd)"
  cd "${image_dir}"
  if [[ -z "${image_tag}" ]];then
    # set to the latest git commit hash
    image_tag=$(git rev-parse HEAD)
  fi
  log_info "image_tag set to: ${image_tag}"

  set -x
  docker build -t "${image_name}:${image_tag}" .
  echo "export AIT_DOCKER_IMAGE_NAME=\"${image_name}\"" > imagerc
  echo "export AIT_DOCKER_IMAGE_TAG=\"${image_tag}\"" >> imagerc

  echo "{ \"docker_image_name\":\"${image_name}\"," > imagerc.json
  echo "\"docker_image_tag\":\"${image_tag}\"," >> imagerc.json
  echo "\"docker_image_url\":\"${image_name}:${image_tag}\" }" >> imagerc.json

  echo "---" > imagerc.yml
  echo "docker_image_name: ${image_name}" >> imagerc.yml
  echo "docker_image_tag:${image_tag}" >> imagerc.yml
  echo "docker_image_url:${image_name}:${image_tag}" >> imagerc.yml
  if [[ "${dryrun}" != "true" ]];then
    docker push "${image_name}:${image_tag}"
  fi
  cd "${initial_dir}"
  set +x
}
function source_imagerc {
  image_dir="$1"

  if [[ -z "${image_dir}" ]];then
    log_error "image_dir not set"
    return 1
  fi
  source "${image_dir}/imagerc"
}
function docker_push {
  image_name="$1"
  testing_image_tag="$2"
  production_image_tag="$3"

  if [[ -z "${image_name}" ]];then
    log_error "image_name not set"
    return 1
  fi
  log_info "image_name set to: ${image_name}"
  if [[ -z "${testing_image_tag}" ]];then
    log_error "testing_image_tag not set"
    return 1
  fi
  log_info "testing_image_tag set to: ${testing_image_tag}"
  if [[ -z "${production_image_tag}" ]];then
    log_error "production_image_tag not set"
    return 1
  fi
  log_info "production_image_tag set to: ${production_image_tag}"
  set -x
  if ! docker images ${image_name} | awk '{print $2}' | grep ${testing_image_tag} 1>/dev/null ; then
    # if docker image does not exist locally, then "docker tag" will fail,
    # so pull it. However, do not always pull it, the image may be not pushed
    # and only available locally.
    docker pull "${image_name}:${testing_image_tag}"
  fi
  # When tagging a docker image using docker 1.8.3, we can use `docker tag -f`.
  # When using docker 1.12, there is no `-f` option, but `docker tag`
  # always works as if force was used.
  docker tag -f "${image_name}:${testing_image_tag}" "${image_name}:${production_image_tag}" || docker tag "${image_name}:${testing_image_tag}" "${image_name}:${production_image_tag}"
  docker tag -f "${image_name}:${testing_image_tag}" "${image_name}:latest" || docker tag "${image_name}:${testing_image_tag}" "${image_name}:latest"
  if [[ "${dryrun}" != "true" ]];then
    docker push "${image_name}:${production_image_tag}"
    docker push "${image_name}:latest"
  fi
  set +x
}
